/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/registers.h"
#include "../Inc/gpio.h"
#include "../Inc/dac.h"
#include "../Inc/adc.h"
#include "../Inc/dma.h"
#include "../Inc/util.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define GPIOA ((GPIO_Register_TypeDef*)0x48000000)
#define RCC ((RCC_Register_TypeDef*)0X40021000)
#define DAC1 ((DAC_Register_TypeDef*)0x50000800)
#define ADC1 ((ADC_Register_TypeDef*)0x50000000)
#define DMA1 ((DMA_Register_TypeDef*)0x40020000)
#define DMAMUX ((DMA_MUX_Register_TypeDef*)0x40020800)

volatile unsigned short adc_value[16];

int main(void)
{
    RCC->AHB2ENR |= 1 << 0; //enable GPIOA clock
	RCC->AHB2ENR |= 1 << 16; //enable DAC clock

	RCC->CCIPR &= ~(0b11 << 28);
	RCC->CCIPR |= 0b10 << 28;
	RCC->AHB2ENR |= 1 << 13; //enable ADC clock
	RCC->AHB1ENR |= 1; //Enable DAC 1 clock
	RCC->AHB1ENR |= 1 << 2;
    __asm__("nop\n\tnop\n\tnop"); //wait for RCC


	configure_gpio(GPIOA, 4, GPIO_MODE_ANALOG, GPIO_SPEED_MEDIUM, GPIO_PULL_NO_PULL, GPIO_TYPE_PUSH_PULL);
	configure_gpio(GPIOA, 3, GPIO_MODE_ANALOG, GPIO_SPEED_MEDIUM, GPIO_PULL_NO_PULL, GPIO_TYPE_PUSH_PULL);

	set_dma_channel(DMA1, false, 1);

	DMA_Channel_Config_TypeDef DMA_Channel_Config = default_dma_channel_config((uint32_t*)&ADC1->DR, adc_value);
	DMA_Channel_Config.circular_mode = true;
	DMA_Channel_Config.memory_size = DMA_MEMORY_SIZE_16BIT;
	DMA_Channel_Config.peripheral_size = DMA_MEMORY_SIZE_16BIT;
	DMA_Channel_Config.priority = DMA_PRIORITY_VERY_HIGH;
	DMA_Channel_Config.memory_increment = true;
	configure_dma_channel(DMA1, &DMA_Channel_Config, 1);

	DMAMUX_Channel_Config_TypeDef dmamux_config = default_dmamux_channel_config();
	dmamux_config.request_event = DMAMUX_EVENT_ADC1;
	configure_dmamux_channel(DMAMUX, &dmamux_config, 0);

	set_dma_channel(DMA1, true, 1);

	RCC->AHB2RSTR |= 1 << 13;    // |
	RCC->AHB2RSTR &= ~(1 << 13); // | Reset ADC

	set_adc(ADC1, 0);

	ADC1->CR &= ~(1 << 29); //Exit deep sleep
	set_adc_voltage_regulator(ADC1, true);

	uint16_t calibration_factors[] = {0, 0};
	calibrate_adc(ADC1, false, calibration_factors);

	set_adc_sampling_time(ADC1, CYCLES47_5, 4, false);

	ADC1->SQR1 &= ~(0b11111 << 6); //Clear first sample channel
	ADC1->SQR1 |= 4 << 6; //Set channel four as first sample

	ADC_Configuration adc_configuration = default_adc_configuration();
	adc_configuration.dma = 1;
	adc_configuration.dma_config = ADC_DMA_CIRCULAR;
	adc_configuration.continuous = 1;
	configure_adc(ADC1, &adc_configuration);

	set_adc(ADC1, true);

	ADC1->CR |= 1 << 2;

	set_dac(DAC1, DMA_CHANNEL_1, false);
	set_dac(DAC1, DMA_CHANNEL_1, true);

	for(;;) {
		DAC1->DHR12R1 = adc_value[0];
	}
}
